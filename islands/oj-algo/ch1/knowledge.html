<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>算法篇第一章 整数理论</title>
    <style>
        /* 全局字体与背景设定 */
        body {
            font-family: "Comic Sans MS", "Chalkboard SE", "Microsoft YaHei", "SimHei", sans-serif;
            background-color: #FFF8E1; /* 暖黄色背景 */
            background-image: radial-gradient(#FFD54F 15%, transparent 16%), radial-gradient(#FFD54F 15%, transparent 16%);
            background-size: 30px 30px;
            background-position: 0 0, 15px 15px;
            color: #333;
            line-height: 1.8;
            margin: 0;
            padding: 20px;
        }

        /* 主容器卡片 */
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #ffffff;
            border-radius: 25px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            padding: 40px;
            border: 5px solid #FFECB3;
        }

        /* 标题样式 */
        h1 {
            text-align: center;
            color: #FF6F00;
            font-size: 2.5em;
            text-shadow: 2px 2px 0px #FFE082;
            margin-bottom: 30px;
            border-bottom: 3px dashed #FFCA28;
            padding-bottom: 15px;
        }

        h2 {
            color: #1565C0;
            background-color: #E3F2FD;
            padding: 10px 20px;
            border-radius: 15px;
            margin-top: 40px;
            border-left: 8px solid #2196F3;
        }

        h3 {
            color: #2E7D32;
            margin-top: 25px;
            font-weight: bold;
        }

        p, li {
            font-size: 1.1em;
            color: #444;
        }

        /* 重点强调 */
        strong {
            color: #D84315;
            background-color: #FFCCBC;
            padding: 0 4px;
            border-radius: 4px;
        }

        blockquote {
            background-color: #F1F8E9;
            border-left: 5px solid #8BC34A;
            margin: 20px 0;
            padding: 15px;
            border-radius: 5px;
            color: #33691E;
        }

        /* 代码块样式 (仿IDE高亮) */
        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 12px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 1em;
            border: 2px solid #546E7A;
            box-shadow: 3px 3px 0px #B0BEC5;
            white-space: pre-wrap; /* 自动换行 */
        }

        /* 代码高亮颜色 */
        .code-kw { color: #c678dd; font-weight: bold; } /* 关键字 int, return, if */
        .code-fn { color: #61afef; } /* 函数 cin, cout, push_back */
        .code-ty { color: #e5c07b; } /* 类型 vector */
        .code-str { color: #98c379; } /* 字符串 "YES" */
        .code-num { color: #d19a66; } /* 数字 */
        .code-com { color: #7f848e; font-style: italic; } /* 注释 */

        /* 插图容器 */
        .img-box {
            text-align: center;
            margin: 30px 0;
        }
        
        /* SVG 插图样式 */
        svg {
            max-width: 100%;
            height: auto;
            filter: drop-shadow(3px 3px 2px rgba(0,0,0,0.1));
        }

        /* 表格样式 */
        .table-box {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .table-box th, .table-box td {
            border: 2px solid #B3E5FC;
            padding: 10px;
            text-align: center;
        }
        .table-box th {
            background-color: #E1F5FE;
            color: #0277BD;
        }

        /* 练习题区域 */
        .exercise-card {
            background-color: #FFF3E0;
            border: 2px dashed #FFB74D;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
        }
        .exercise-title {
            color: #EF6C00;
            font-weight: bold;
            font-size: 1.3em;
            margin-bottom: 10px;
        }

    </style>
</head>
<body>

<div class="container">

    <h1>🎮 算法篇第一章 整数理论大冒险 🍎</h1>

    <section>
        <h2>一、趣味开场（导入）</h2>
        <p>想象一下，你有 12 个苹果，想要请同学们一起吃。你把苹果一人一个地往外发：</p>
        
        <div class="img-box">
            <svg width="400" height="150" viewBox="0 0 400 150">
                <g fill="#FF5252" stroke="#B71C1C" stroke-width="2">
                    <circle cx="30" cy="30" r="15"/><circle cx="70" cy="30" r="15"/><circle cx="110" cy="30" r="15"/><circle cx="150" cy="30" r="15"/>
                    <circle cx="30" cy="70" r="15"/><circle cx="70" cy="70" r="15"/><circle cx="110" cy="70" r="15"/><circle cx="150" cy="70" r="15"/>
                    <circle cx="30" cy="110" r="15"/><circle cx="70" cy="110" r="15"/><circle cx="110" cy="110" r="15"/><circle cx="150" cy="110" r="15"/>
                </g>
                <g fill="#4CAF50">
                    <path d="M30 15 Q35 5 40 15"/><path d="M70 15 Q75 5 80 15"/><path d="M110 15 Q115 5 120 15"/><path d="M150 15 Q155 5 160 15"/>
                    <path d="M30 55 Q35 45 40 55"/><path d="M70 55 Q75 45 80 55"/><path d="M110 55 Q115 45 120 55"/><path d="M150 55 Q155 45 160 55"/>
                    <path d="M30 95 Q35 85 40 95"/><path d="M70 95 Q75 85 80 95"/><path d="M110 95 Q115 85 120 95"/><path d="M150 95 Q155 85 160 95"/>
                </g>
                <text x="220" y="40" font-family="Comic Sans MS" font-size="16" fill="#333">😊 2人分: 每人 6 个 (✔)</text>
                <text x="220" y="80" font-family="Comic Sans MS" font-size="16" fill="#333">😃 3人分: 每人 4 个 (✔)</text>
                <text x="220" y="120" font-family="Comic Sans MS" font-size="16" fill="#D84315">😅 5人分: 剩 2 个 (❌)</text>
            </svg>
        </div>

        <ul>
            <li>2 个人分，每人 6 个；</li>
            <li>3 个人分，每人 4 个；</li>
            <li>5 个人分，就尴尬了，会剩下 2 个。</li>
        </ul>

        <p>这时候，你脑子里其实已经在做一件事——判断某个数能不能“整整齐齐地分掉另一个数”，这就是“<strong>整除</strong>”和“<strong>约数</strong>”的世界啦。</p>
        
        <p>再想象你在玩一个“敲鼓游戏”：地上写着好多数字，每当你喊出一个数它的“倍数小弟”都要站出来。比如你喊“3”，地上写着的 3、6、9、12 都要啪啪站起来。</p>
        
        <p>“约数”“倍数”“质数”这些听起来有点严肃的词，其实就是在玩这种“谁能整谁”的游戏。</p>
        
        <p>还有一个场景：体育老师让大家排队报数，报到 2 和 5 的要做俯卧撑。你会发现有的同学要做很多次，因为他既是 2 的倍数又是 5 的倍数。这背后其实就在考你：哪些数是“好朋友”（公因数），哪些数是“共同生日”（最大公约数、最小公倍数）。</p>
        
        <p>今天这节课，我们就来做一件酷酷的事——用 <strong>C++14</strong> 来玩“整数理论”的游戏：分苹果、数约数、找质数、算最大公约数、最小公倍数……听起来就很像一整套奥数 + 编程的组合拳，对吧？😎</p>
    </section>

    <section>
        <h2>二、知识点讲解</h2> 

        <h3>知识点 1：整除与约数</h3>
        <h4>1. 白话定义</h4>
        <p>有两个整数 a 和 b，如果可以找到一个整数 q，让 <strong>b = a × q</strong>，那就说 “a 能整除 b”，记作 <strong>a | b</strong>。</p>
        <p>这时候：</p>
        <ul>
            <li><strong>a</strong> 叫 <strong>b</strong> 的约数（除数）；</li>
            <li><strong>b</strong> 叫 <strong>a</strong> 的倍数。</li>
        </ul>

        <h4>2. 生活类比</h4>
        <ul>
            <li>“12 个苹果平均分给 3 个同学，每人 4 个”，说明 3 能整除 12。</li>
            <li>“12 个苹果分给 5 个同学，一人 2 个，还剩 2 个”，说明 5 不能整除 12。</li>
        </ul>
        <p>我们常常会问的问题：“x 个人来分 n 个苹果，能不能分得刚刚好？”其实就是在问：x 是不是 n 的约数。</p>

        <h4>3. 小小性质</h4>
        <ul>
            <li>若 a | b，b | c，那么 a | c。（传递性，像接力跑）</li>
            <li>若 a | b，a | c，那么 a 也能整除 b*x + c*y（x,y 是任意整数）。——理解成：“如果 a 能平均切开两个蛋糕，那这两个蛋糕随便搬几次、加一加，总蛋糕数还是能被 a 切开。”</li>
            <li>若 a | b，m ≠ 0，那么 ma | mb。——两个数一起都乘同一个倍数，整除关系不会变。</li>
        </ul>

        <h4>4. C++14 示例：判断能不能平均分</h4>
<pre>
<span class="code-kw">#include</span> &lt;bits/stdc++.h&gt;
<span class="code-kw">using</span> <span class="code-kw">namespace</span> std;

<span class="code-kw">int</span> main() {
    <span class="code-kw">int</span> n, x;
    cin >> n >> x;          <span class="code-com">// 输入苹果数 n 和人数 x</span>
    <span class="code-kw">if</span> (n % x == <span class="code-num">0</span>) {       <span class="code-com">// 如果 n 能被 x 整除</span>
        cout << <span class="code-str">"YES\n"</span>;    <span class="code-com">// 能平均分</span>
    } <span class="code-kw">else</span> {
        cout << <span class="code-str">"NO\n"</span>;     <span class="code-com">// 分不均匀</span>
    }
    <span class="code-kw">return</span> <span class="code-num">0</span>;
}
</pre>

        <hr>

        <h3>知识点 2：用 √n 优化找约数（枚举约数）</h3>
        <h4>1. 白话思路</h4>
        <p>想要找到一个数 n 的所有约数，最笨的办法是：从 1 一直试到 n，看谁能整除它。</p>
        <p>但我们发现：<strong>约数是成对出现的</strong>：如果 k 是 n 的约数，那 n / k 也是 n 的约数。</p>
        <div class="img-box">
             <svg width="500" height="100" viewBox="0 0 500 100">
                <rect x="10" y="10" width="480" height="80" rx="10" fill="#E1F5FE" stroke="#039BE5" stroke-width="2"/>
                <text x="250" y="30" text-anchor="middle" font-weight="bold" fill="#0277BD">120 的约数配对</text>
                <line x1="250" y1="40" x2="250" y2="85" stroke="#0277BD" stroke-dasharray="4"/>
                <text x="40" y="70" fill="#333">1</text>
                <text x="440" y="70" fill="#333">120</text>
                <path d="M50 65 Q 250 10 440 65" fill="none" stroke="#FF7043" stroke-width="2"/>
                
                <text x="80" y="70" fill="#333">2</text>
                <text x="400" y="70" fill="#333">60</text>
                <path d="M90 65 Q 250 25 400 65" fill="none" stroke="#66BB6A" stroke-width="2"/>
                
                <text x="120" y="70" fill="#333">...</text>
                <text x="250" y="85" text-anchor="middle" fill="#555" font-size="12">只需要找这边 (√n)</text>
            </svg>
        </div>
        <p>例如 120：1 ↔ 120, 2 ↔ 60, 10 ↔ 12... 所以只要枚举到 k * k <= n（也就是 k <= √n）就够了，每找到一个约数 k，就可以顺便得到另一个约数 n / k。</p>

        <h4>2. 类比</h4>
        <p>想象你在找“身高配对”：规定两个人身高乘积是 120。如果你找到一个 4cm 的“小积木人”，另一个“搭档”一定是 30cm。你只需要往上找，找到一半（约 √120）就可以把所有搭档找完。</p>

        <h4>3. C++14 示例：找出所有约数并存进数组</h4>
<pre>
<span class="code-kw">#include</span> &lt;bits/stdc++.h&gt;
<span class="code-kw">using</span> <span class="code-kw">namespace</span> std;

<span class="code-com">// 把 n 的所有约数存到 vector 里，并按从小到大排序</span>
vector&lt;<span class="code-kw">int</span>&gt; get_divisors(<span class="code-kw">int</span> n) {
    vector&lt;<span class="code-kw">int</span>&gt; d;
    <span class="code-kw">for</span> (<span class="code-kw">int</span> k = <span class="code-num">1</span>; k * k <= n; ++k) {   <span class="code-com">// 只枚举到 sqrt(n)</span>
        <span class="code-kw">if</span> (n % k == <span class="code-num">0</span>) {               <span class="code-com">// 找到一个约数 k</span>
            d.push_back(k);             <span class="code-com">// 加入 k</span>
            <span class="code-kw">if</span> (k * k != n) {           <span class="code-com">// 如果另一半不是同一个数</span>
                d.push_back(n / k);     <span class="code-com">// 再加上 n / k</span>
            }
        }
    }
    sort(d.begin(), d.end());           <span class="code-com">// 排序，变成从小到大</span>
    <span class="code-kw">return</span> d;
}

<span class="code-kw">int</span> main() {
    <span class="code-kw">int</span> n;
    cin >> n;
    vector&lt;<span class="code-kw">int</span>&gt; d = get_divisors(n);
    cout << <span class="code-str">"约数个数 = "</span> << d.size() << <span class="code-str">"\n"</span>;
    cout << <span class="code-str">"所有约数："</span>;
    <span class="code-kw">for</span> (<span class="code-kw">int</span> x : d) cout << x << <span class="code-str">" "</span>;
    cout << <span class="code-str">"\n"</span>;
    <span class="code-kw">return</span> <span class="code-num">0</span>;
}
</pre>

        <hr>

        <h3>知识点 3：质数与合数 + 判断质数</h3>
        <h4>1. 白话定义</h4>
        <p>一个大于等于 2 的整数：</p>
        <ul>
            <li>只含有 1 和它本身两个约数 → <strong>质数</strong>（prime）；</li>
            <li>有其他约数 → <strong>合数</strong>（composite）。</li>
        </ul>
        <p><strong>重要结论：</strong>如果 a 是合数，那一定可以写成 a = p × q，并且至少有一个质因子 p ≤ √a。所以判断一个数是不是质数，只需要试所有 2 ≤ i ≤ √a，如果都不能整除，就可以认定它是质数。</p>

        <h4>2. 类比</h4>
        <p>想象你在检查一块“乐高砖块”是不是“基本砖块”：如果它可以拆成两块更小的整数长度砖块，那它是“合体砖”（合数）；如果拆不开，只能是 1 和它自己，那就是“质数砖”。</p>

        <h4>3. C++14 示例：判断一个数是否是质数</h4>
<pre>
<span class="code-kw">#include</span> &lt;bits/stdc++.h&gt;
<span class="code-kw">using</span> <span class="code-kw">namespace</span> std;

<span class="code-kw">bool</span> is_prime(<span class="code-kw">int</span> x) {
    <span class="code-kw">if</span> (x < <span class="code-num">2</span>) <span class="code-kw">return</span> <span class="code-kw">false</span>;              <span class="code-com">// 小于 2 的不是质数</span>
    <span class="code-kw">for</span> (<span class="code-kw">int</span> i = <span class="code-num">2</span>; i * i <= x; ++i) {    <span class="code-com">// 只试到 sqrt(x)</span>
        <span class="code-kw">if</span> (x % i == <span class="code-num">0</span>) <span class="code-kw">return</span> <span class="code-kw">false</span>;     <span class="code-com">// 找到能整除的，说明是合数</span>
    }
    <span class="code-kw">return</span> <span class="code-kw">true</span>;                          <span class="code-com">// 没找到约数，就是质数</span>
}

<span class="code-kw">int</span> main() {
    <span class="code-kw">int</span> n;
    cin >> n;
    <span class="code-kw">if</span> (is_prime(n)) cout << <span class="code-str">"Prime\n"</span>;
    <span class="code-kw">else</span> cout << <span class="code-str">"Not prime\n"</span>;
    <span class="code-kw">return</span> <span class="code-num">0</span>;
}
</pre>

        <hr>

        <h3>知识点 4：埃拉托斯特尼筛法（素数筛）</h3>
        <h4>1. 白话思路</h4>
        <p>要找 1 到 N 之间所有的质数，一个个用 is_prime 判断会有点慢。</p>
        <p><strong>更聪明的做法：</strong></p>
        <ol>
            <li>一开始假装 2～N 都是质数；</li>
            <li>从 2 开始，把它的倍数统统划掉（因为它们一定有约数 2，是合数）；</li>
            <li>再找下一个没被划掉的数 3，把 3 的倍数划掉……</li>
            <li>最后没有被划掉的，就是质数。</li>
        </ol>

        <div class="img-box">
             <svg width="400" height="150" viewBox="0 0 400 150">
                <rect x="0" y="0" width="400" height="150" rx="10" fill="#FFF" stroke="#FFAB00" stroke-width="2"/>
                <g font-family="monospace" font-size="20" text-anchor="middle">
                    <text x="30" y="40" fill="#CCC" text-decoration="line-through">1</text>
                    <circle cx="70" cy="35" r="15" fill="none" stroke="#D32F2F" stroke-width="2"/> <text x="70" y="40" fill="#D32F2F" font-weight="bold">2</text>
                    <circle cx="110" cy="35" r="15" fill="none" stroke="#D32F2F" stroke-width="2"/> <text x="110" y="40" fill="#D32F2F" font-weight="bold">3</text>
                    <text x="150" y="40" fill="#999">4</text><line x1="140" y1="40" x2="160" y2="30" stroke="red" stroke-width="2"/>
                    <circle cx="190" cy="35" r="15" fill="none" stroke="#D32F2F" stroke-width="2"/> <text x="190" y="40" fill="#D32F2F" font-weight="bold">5</text>
                    <text x="230" y="40" fill="#999">6</text><line x1="220" y1="40" x2="240" y2="30" stroke="red" stroke-width="2"/>
                    <circle cx="270" cy="35" r="15" fill="none" stroke="#D32F2F" stroke-width="2"/> <text x="270" y="40" fill="#D32F2F" font-weight="bold">7</text>
                    <text x="310" y="40" fill="#999">8</text><line x1="300" y1="40" x2="320" y2="30" stroke="red" stroke-width="2"/>
                    <text x="350" y="40" fill="#999">9</text><line x1="340" y1="40" x2="360" y2="30" stroke="red" stroke-width="2"/>
                </g>
                <text x="200" y="100" text-anchor="middle" font-size="14" fill="#555">划掉 2 的倍数... 划掉 3 的倍数...</text>
                <text x="200" y="130" text-anchor="middle" font-size="14" fill="#D32F2F" font-weight="bold">剩下的红圈就是质数！</text>
            </svg>
        </div>

        <h4>2. C++14 示例：筛出 1～N 之间所有质数</h4>
<pre>
<span class="code-kw">#include</span> &lt;bits/stdc++.h&gt;
<span class="code-kw">using</span> <span class="code-kw">namespace</span> std;

<span class="code-kw">const</span> <span class="code-kw">int</span> MAXN = <span class="code-num">1000000</span>;   <span class="code-com">// N 的最大可能值</span>
<span class="code-kw">bool</span> is_composite[MAXN + <span class="code-num">1</span>]; <span class="code-com">// false 表示暂时认为是质数</span>

<span class="code-kw">int</span> main() {
    <span class="code-kw">int</span> N;
    cin >> N;

    is_composite[<span class="code-num">0</span>] = is_composite[<span class="code-num">1</span>] = <span class="code-kw">true</span>; <span class="code-com">// 0 和 1 不是质数</span>

    <span class="code-kw">for</span> (<span class="code-kw">int</span> i = <span class="code-num">2</span>; i * i <= N; ++i) {
        <span class="code-kw">if</span> (!is_composite[i]) {              <span class="code-com">// i 还是质数</span>
            <span class="code-kw">for</span> (<span class="code-kw">int</span> j = i * i; j <= N; j += i) {
                is_composite[j] = <span class="code-kw">true</span>;      <span class="code-com">// j 是 i 的倍数，所以是合数</span>
            }
        }
    }

    cout << <span class="code-str">"1~"</span> << N << <span class="code-str">" 之间的质数有：\n"</span>;
    <span class="code-kw">for</span> (<span class="code-kw">int</span> i = <span class="code-num">2</span>; i <= N; ++i) {
        <span class="code-kw">if</span> (!is_composite[i]) cout << i << <span class="code-str">" "</span>;
    }
    cout << <span class="code-str">"\n"</span>;
    <span class="code-kw">return</span> <span class="code-num">0</span>;
}
</pre>
        <p><strong>进阶：</strong>图片里还给出了“区间筛”的版本，可以统计 [L,R] 中有多少个质数。思想是：先筛出所有不超过 √R 的质数，再在 [L,R] 这段小区间上划掉它们的倍数。</p>

        <hr>

        <h3>知识点 5：最大公约数 GCD 和最小公倍数 LCM</h3>
        <h4>1. 白话定义</h4>
        <ul>
            <li><strong>最大公约数 gcd(a, b)</strong>：能同时整除它们的最大的数。</li>
            <li><strong>最小公倍数 lcm(a, b)</strong>：能同时被它们整除的最小的数。</li>
            <li><strong>重要公式：</strong> a × b = gcd(a, b) × lcm(a, b)</li>
        </ul>

        <h4>2. 生活类比：木棍问题</h4>
        <p>有两根木棍，分别长 10cm 和 16cm。</p>
        <ul>
            <li>要切成长度相同的小段，不能有剩的 → 每小段最长是 <strong>gcd(10,16) = 2cm</strong>。</li>
            <li>再来一根木棍，既可以切出若干根 10cm，又可以切出若干根 16cm → 最短长度是 <strong>lcm(10,16) = 80cm</strong>。</li>
        </ul>

        <h4>3. 欧几里得算法（辗转相除法）</h4>
        <p>计算 gcd 的超好用公式：<code>gcd(x, y) = gcd(y, x % y)</code></p>
        <blockquote>
            例：gcd(18, 12)<br>
            18 % 12 = 6 → gcd(18,12) = gcd(12,6)<br>
            12 % 6 = 0 → gcd(12,6) = 6<br>
            所以 gcd(18,12) = 6。
        </blockquote>

        <h4>4. C++14 示例：gcd + lcm</h4>
<pre>
<span class="code-kw">#include</span> &lt;bits/stdc++.h&gt;
<span class="code-kw">using</span> <span class="code-kw">namespace</span> std;

<span class="code-com">// 欧几里得算法，递归写法</span>
<span class="code-kw">int</span> gcd(<span class="code-kw">int</span> x, <span class="code-kw">int</span> y) {
    <span class="code-kw">return</span> y == <span class="code-num">0</span> ? x : gcd(y, x % y); <span class="code-com">// y 为 0 时，x 就是答案</span>
}

<span class="code-kw">long long</span> lcm(<span class="code-kw">long long</span> a, <span class="code-kw">long long</span> b) {
    <span class="code-com">// 先求最大公约数，再用 a*b/gcd 得到最小公倍数</span>
    <span class="code-kw">return</span> a / gcd(a, b) * b;          <span class="code-com">// 先除后乘，减少溢出风险</span>
}

<span class="code-kw">int</span> main() {
    <span class="code-kw">long long</span> a, b;
    cin >> a >> b;
    cout << <span class="code-str">"gcd = "</span> << gcd(a, b) << <span class="code-str">"\n"</span>;
    cout << <span class="code-str">"lcm = "</span> << lcm(a, b) << <span class="code-str">"\n"</span>;
    <span class="code-kw">return</span> <span class="code-num">0</span>;
}
</pre>

        <hr>

        <h3>知识点 6（进阶）：“拍头”与贡献法 —— 统计倍数个数</h3>
        <h4>1. 题目大意</h4>
        <p>有 n 个正整数排成一排，每个数头上写着一个值。对于每个数 a[i]，我们想知道：它是另外多少个数的倍数。</p>

        <h4>2. 换个角度：贡献法</h4>
        <p><strong>贡献法思路：</strong></p>
        <ol>
            <li>先统计：每个数值 x 在数组里出现了多少次，记为 c[x]。</li>
            <li>然后，对于每个数值 i，把它的出现次数 c[i] 统统“传给”它的所有倍数 j（2i, 3i, 4i ...），对每个 j 加上 c[i]。</li>
            <li>最后，对于数值 v，它头上的计数 w[v] 就表示：数组中有多少个数是它的约数。</li>
            <li>减掉自己：答案是 w[a[i]] - 1。</li>
        </ol>

        <h4>3. 简化版 C++14 示例（核心循环）</h4>
<pre>
<span class="code-kw">#include</span> &lt;bits/stdc++.h&gt;
<span class="code-kw">using</span> <span class="code-kw">namespace</span> std;

<span class="code-kw">const</span> <span class="code-kw">int</span> MAXV = <span class="code-num">1000000</span>;  <span class="code-com">// 数值上限</span>

<span class="code-kw">int</span> main() {
    <span class="code-kw">int</span> n;
    cin >> n;
    vector&lt;<span class="code-kw">int</span>&gt; a(n + <span class="code-num">1</span>);
    <span class="code-kw">static int</span> cnt[MAXV + <span class="code-num">1</span>], w[MAXV + <span class="code-num">1</span>];

    <span class="code-kw">for</span> (<span class="code-kw">int</span> i = <span class="code-num">1</span>; i <= n; ++i) {
        cin >> a[i];          <span class="code-com">// 读入原数组</span>
        cnt[a[i]]++;          <span class="code-com">// 统计每个值出现次数</span>
    }

    <span class="code-com">// 对每个可能的数 i，把它向所有倍数 j 传递“出现次数”的贡献</span>
    <span class="code-kw">for</span> (<span class="code-kw">int</span> i = <span class="code-num">1</span>; i <= MAXV; ++i) {
        <span class="code-kw">if</span> (cnt[i] == <span class="code-num">0</span>) <span class="code-kw">continue</span>;      <span class="code-com">// 这个数根本没出现，就跳过</span>
        <span class="code-kw">for</span> (<span class="code-kw">int</span> j = i; j <= MAXV; j += i) {
            w[j] += cnt[i];             <span class="code-com">// i 会给它所有倍数 j 做贡献</span>
        }
    }

    <span class="code-com">// 输出每个 a[i] 的答案：它是另外多少个数的倍数</span>
    <span class="code-kw">for</span> (<span class="code-kw">int</span> i = <span class="code-num">1</span>; i <= n; ++i) {
        cout << w[a[i]] - <span class="code-num">1</span> << <span class="code-str">" "</span>;     <span class="code-com">// 减掉自己那一次</span>
    }
    cout << <span class="code-str">"\n"</span>;
    <span class="code-kw">return</span> <span class="code-num">0</span>;
}
</pre>
    </section>

    <section>
        <h2>三、常见题型总结（面向 CSP-J）</h2>
        <div style="display: flex; flex-wrap: wrap; gap: 15px;">
            <div style="flex: 1 1 300px; background: #E0F7FA; padding: 15px; border-radius: 10px;">
                <strong>题型 1：整除判断 & 平均分</strong><br>
                核心：判断 <code>a % b == 0</code>。<br>
                坑点：忘记 b > a 的情况；Yes/NO 大小写错误。
            </div>
            <div style="flex: 1 1 300px; background: #F3E5F5; padding: 15px; border-radius: 10px;">
                <strong>题型 2：约数枚举</strong><br>
                核心：<code>√n</code> 优化。<br>
                坑点：<code>k * k == n</code> 时重复计算；数组下标搞混。
            </div>
            <div style="flex: 1 1 300px; background: #FFF3E0; padding: 15px; border-radius: 10px;">
                <strong>题型 3：质数相关</strong><br>
                核心：is_prime 或 筛法。<br>
                坑点：把 1 当质数；循环范围写错导致超时。
            </div>
            <div style="flex: 1 1 300px; background: #E8F5E9; padding: 15px; border-radius: 10px;">
                <strong>题型 4：GCD / LCM</strong><br>
                核心：欧几里得算法。<br>
                坑点：乘法爆 int (用 long long)；递归死循环。
            </div>
            <div style="flex: 1 1 300px; background: #FFEBEE; padding: 15px; border-radius: 10px;">
                <strong>题型 5：倍数统计 (进阶)</strong><br>
                核心：贡献法 (O(n log n))。<br>
                坑点：双重循环超时；没减掉“自己”。
            </div>
        </div>
    </section>

    <section>
        <h2>四、课堂练习题 ✍️</h2>
        <p>下面 6 道练习题，从简单到进阶，请动手写一写吧！</p>

        <div class="exercise-card">
            <div class="exercise-title">练习 1：能不能平均分？（整除判断）</div>
            <p><strong>题目描述：</strong>小明带来了一大袋苹果，一共有 n 个。现在有 x 个同学来一起吃。每个同学必须得到一样多的苹果，而且不能切半个苹果。请你帮老师判断：这袋苹果能不能平均分给这 x 个同学？</p>
            <p><strong>输入：</strong>两个正整数 n 和 x。<br><strong>输出：</strong>可以平均分输出 YES，否则输出 NO。</p>
            <div style="background:#fff; padding:10px; border-radius:8px;">
                <strong>样例 1：</strong> 输入 <code>12 3</code> → 输出 <code>YES</code><br>
                <strong>样例 2：</strong> 输入 <code>12 5</code> → 输出 <code>NO</code>
            </div>
            <details>
                <summary style="cursor:pointer; color:#1976D2; margin-top:10px; font-weight:bold;">查看参考代码 (C++14)</summary>
<pre>
<span class="code-kw">#include</span> &lt;bits/stdc++.h&gt;
<span class="code-kw">using</span> <span class="code-kw">namespace</span> std;
<span class="code-kw">int</span> main() {
    <span class="code-kw">long long</span> n, x;
    cin >> n >> x;
    <span class="code-kw">if</span> (n % x == <span class="code-num">0</span>) cout << <span class="code-str">"YES\n"</span>;
    <span class="code-kw">else</span> cout << <span class="code-str">"NO\n"</span>;
    <span class="code-kw">return</span> <span class="code-num">0</span>;
}
</pre>
            </details>
        </div>

        <div class="exercise-card">
            <div class="exercise-title">练习 2：苹果可以怎么分？（枚举约数）</div>
            <p><strong>题目描述：</strong>有多少种人数 x 可以把 n 个苹果分得刚刚好？请输出种类数和所有的 x（从小到大）。</p>
            <div style="background:#fff; padding:10px; border-radius:8px;">
                <strong>样例 1：</strong> 输入 <code>12</code> → 输出 <code>6</code> (换行) <code>1 2 3 4 6 12</code>
            </div>
            <details>
                <summary style="cursor:pointer; color:#1976D2; margin-top:10px; font-weight:bold;">查看参考代码 (C++14)</summary>
<pre>
<span class="code-kw">#include</span> &lt;bits/stdc++.h&gt;
<span class="code-kw">using</span> <span class="code-kw">namespace</span> std;
<span class="code-kw">int</span> main() {
    <span class="code-kw">long long</span> n;
    cin >> n;
    vector&lt;<span class="code-kw">long long</span>&gt; d;
    <span class="code-kw">for</span> (<span class="code-kw">long long</span> k = <span class="code-num">1</span>; k * k <= n; ++k) {
        <span class="code-kw">if</span> (n % k == <span class="code-num">0</span>) {
            d.push_back(k);
            <span class="code-kw">if</span> (k * k != n) d.push_back(n / k);
        }
    }
    sort(d.begin(), d.end());
    cout << d.size() << <span class="code-str">"\n"</span>;
    <span class="code-kw">for</span> (<span class="code-kw">long long</span> x : d) cout << x << <span class="code-str">" "</span>;
    cout << <span class="code-str">"\n"</span>;
    <span class="code-kw">return</span> <span class="code-num">0</span>;
}
</pre>
            </details>
        </div>

        <div class="exercise-card">
            <div class="exercise-title">练习 3：最小循环节（字符串版约数应用）</div>
            <p><strong>题目描述：</strong>给你一个字符串 s，问它是不是由一个更短的小串重复若干次拼成的？输出最短的小串长度。</p>
            <div style="background:#fff; padding:10px; border-radius:8px;">
                <strong>样例 1：</strong> 输入 <code>abbaabbaabba</code> → 输出 <code>4</code>
            </div>
            <details>
                <summary style="cursor:pointer; color:#1976D2; margin-top:10px; font-weight:bold;">查看思路与代码</summary>
                <p>思路：枚举长度 n 的所有约数 len，检查 s[i] == s[i % len]。</p>
<pre>
<span class="code-kw">#include</span> &lt;bits/stdc++.h&gt;
<span class="code-kw">using</span> <span class="code-kw">namespace</span> std;
<span class="code-kw">int</span> main() {
    string s;
    cin >> s;
    <span class="code-kw">int</span> n = (<span class="code-kw">int</span>)s.size();
    <span class="code-kw">for</span> (<span class="code-kw">int</span> len = <span class="code-num">1</span>; len <= n; ++len) {
        <span class="code-kw">if</span> (n % len == <span class="code-num">0</span>) { <span class="code-com">// 必须是约数</span>
            <span class="code-kw">bool</span> ok = <span class="code-kw">true</span>;
            <span class="code-kw">for</span> (<span class="code-kw">int</span> i = <span class="code-num">0</span>; i < n; ++i) {
                <span class="code-kw">if</span> (s[i] != s[i % len]) {
                    ok = <span class="code-kw">false</span>; <span class="code-kw">break</span>;
                }
            }
            <span class="code-kw">if</span> (ok) {
                cout << len << <span class="code-str">"\n"</span>;
                <span class="code-kw">return</span> <span class="code-num">0</span>;
            }
        }
    }
    <span class="code-kw">return</span> <span class="code-num">0</span>;
}
</pre>
            </details>
        </div>

        <div class="exercise-card">
            <div class="exercise-title">练习 4：拍头游戏（倍数统计）</div>
            <p><strong>题目描述：</strong>n 个小朋友，每人有个数字 a[i]。问每个人：自己是另外多少个人的倍数？</p>
            <div style="background:#fff; padding:10px; border-radius:8px;">
                <strong>样例 1：</strong> 输入 5 / 2 1 2 3 4 → 输出 2 0 2 1 3
            </div>
            <details>
                <summary style="cursor:pointer; color:#1976D2; margin-top:10px; font-weight:bold;">查看参考代码 (贡献法)</summary>
<pre>
<span class="code-kw">#include</span> &lt;bits/stdc++.h&gt;
<span class="code-kw">using</span> <span class="code-kw">namespace</span> std;
<span class="code-kw">const</span> <span class="code-kw">int</span> MAXV = <span class="code-num">1000000</span>;
<span class="code-kw">int</span> main() {
    <span class="code-kw">int</span> n;
    cin >> n;
    vector&lt;<span class="code-kw">int</span>&gt; a(n + <span class="code-num">1</span>);
    <span class="code-kw">static int</span> cnt[MAXV + <span class="code-num">1</span>], w[MAXV + <span class="code-num">1</span>];
    <span class="code-kw">int</span> maxVal = <span class="code-num">0</span>;
    <span class="code-kw">for</span> (<span class="code-kw">int</span> i = <span class="code-num">1</span>; i <= n; ++i) {
        cin >> a[i]; cnt[a[i]]++; maxVal = max(maxVal, a[i]);
    }
    <span class="code-kw">for</span> (<span class="code-kw">int</span> i = <span class="code-num">1</span>; i <= maxVal; ++i) {
        <span class="code-kw">if</span> (cnt[i] == <span class="code-num">0</span>) <span class="code-kw">continue</span>;
        <span class="code-kw">for</span> (<span class="code-kw">int</span> j = i; j <= maxVal; j += i) w[j] += cnt[i];
    }
    <span class="code-kw">for</span> (<span class="code-kw">int</span> i = <span class="code-num">1</span>; i <= n; ++i) cout << w[a[i]] - <span class="code-num">1</span> << (i < n ? <span class="code-str">" "</span> : <span class="code-str">""</span>);
    cout << <span class="code-str">"\n"</span>;
    <span class="code-kw">return</span> <span class="code-num">0</span>;
}
</pre>
            </details>
        </div>

        <div class="exercise-card">
            <div class="exercise-title">练习 5：1～N 之间有多少质数？</div>
            <p><strong>题目描述：</strong>求 1 到 N 之间所有质数的个数，并输出它们。</p>
            <div style="background:#fff; padding:10px; border-radius:8px;">
                <strong>样例：</strong> 输入 10 → 输出 4 (换行) 2 3 5 7
            </div>
            <details>
                <summary style="cursor:pointer; color:#1976D2; margin-top:10px; font-weight:bold;">查看参考代码 (筛法)</summary>
<pre>
<span class="code-kw">#include</span> &lt;bits/stdc++.h&gt;
<span class="code-kw">using</span> <span class="code-kw">namespace</span> std;
<span class="code-kw">const</span> <span class="code-kw">int</span> MAXN = <span class="code-num">1000000</span>;
<span class="code-kw">bool</span> is_composite[MAXN + <span class="code-num">1</span>];
<span class="code-kw">int</span> main() {
    <span class="code-kw">int</span> N;
    cin >> N;
    is_composite[<span class="code-num">0</span>] = is_composite[<span class="code-num">1</span>] = <span class="code-kw">true</span>;
    <span class="code-kw">for</span> (<span class="code-kw">int</span> i = <span class="code-num">2</span>; i * i <= N; ++i) {
        <span class="code-kw">if</span> (!is_composite[i]) {
            <span class="code-kw">for</span> (<span class="code-kw">int</span> j = i * i; j <= N; j += i) is_composite[j] = <span class="code-kw">true</span>;
        }
    }
    vector&lt;<span class="code-kw">int</span>&gt; primes;
    <span class="code-kw">for</span> (<span class="code-kw">int</span> i = <span class="code-num">2</span>; i <= N; ++i) <span class="code-kw">if</span> (!is_composite[i]) primes.push_back(i);
    cout << primes.size() << <span class="code-str">"\n"</span>;
    <span class="code-kw">for</span> (<span class="code-kw">int</span> x : primes) cout << x << <span class="code-str">" "</span>;
    cout << <span class="code-str">"\n"</span>;
    <span class="code-kw">return</span> <span class="code-num">0</span>;
}
</pre>
            </details>
        </div>

        <div class="exercise-card">
            <div class="exercise-title">练习 6：木棍大作战（GCD & LCM）</div>
            <p><strong>题目描述：</strong>给两个数 a 和 b，求它们的最大公约数和最小公倍数。</p>
            <div style="background:#fff; padding:10px; border-radius:8px;">
                <strong>样例：</strong> 输入 10 16 → 输出 2 (换行) 80
            </div>
            <details>
                <summary style="cursor:pointer; color:#1976D2; margin-top:10px; font-weight:bold;">查看参考代码</summary>
<pre>
<span class="code-kw">#include</span> &lt;bits/stdc++.h&gt;
<span class="code-kw">using</span> <span class="code-kw">namespace</span> std;
<span class="code-kw">long long</span> gcd_ll(<span class="code-kw">long long</span> x, <span class="code-kw">long long</span> y) {
    <span class="code-kw">return</span> y == <span class="code-num">0</span> ? x : gcd_ll(y, x % y);
}
<span class="code-kw">int</span> main() {
    <span class="code-kw">long long</span> a, b;
    cin >> a >> b;
    <span class="code-kw">long long</span> g = gcd_ll(a, b);
    <span class="code-kw">long long</span> l = a / g * b;
    cout << g << <span class="code-str">"\n"</span> << l << <span class="code-str">"\n"</span>;
    <span class="code-kw">return</span> <span class="code-num">0</span>;
}
</pre>
            </details>
        </div>
    </section>

    <section>
        <h2>五、课堂小结与提问</h2>
        <div style="background: #FFFDE7; padding: 20px; border-radius: 15px; border: 2px solid #FFD54F;">
            <h3>🌟 今日成就</h3>
            <ul>
                <li>认识了 <strong>整除、约数、倍数</strong>，知道了 “a | b” 就是 “b 能被 a 整整齐齐地分开”。</li>
                <li>学会了用 <strong>枚举到 √n</strong> 的方式来找约数，大大减少了循环次数。</li>
                <li>学会识别 <strong>质数与合数</strong>，掌握了用 <strong>埃拉托斯特尼筛</strong> 来快速找出很多质数。</li>
                <li>掌握了 <strong>最大公约数 gcd</strong> 和 <strong>最小公倍数 lcm</strong>，能用欧几里得算法快速求 gcd。</li>
                <li>见识了进阶技巧：用“贡献法”解决倍数统计问题。</li>
            </ul>
            <p>这些内容几乎把整数理论里最常见、最实用的武器都发给你了，你已经离 CSP-J 大神又近了一大步！✨</p>

            <h3>🚧 容易掉坑的地方</h3>
            <ul>
                <li>把 1 当成质数，或者忘记从 2 开始枚举。</li>
                <li>枚举约数时没有考虑 <code>k * k == n</code> 的特殊情况，导致重复计数。</li>
                <li><code>int</code> 不够用的时候忘记换成 <code>long long</code>，乘法溢出。</li>
            </ul>

            <h3>🤔 思考题</h3>
            <p>如果数据变得非常大，比如 n 可以到 10^12，上面的求约数方法、质数筛方法，还能用吗？哪些地方要改？你会怎么做优化？</p>
            <p><strong>恭喜你——整数理论这一关，已经可以自信打怪了！接下来就可以在 CSP-J 真题里大显身手啦！💪🔥</strong></p>
        </div>
    </section>

</div>

</body>
</html>